{"name":"GSteg","tagline":"Qt Steg library","body":"#QSteg#\r\nSteganography thing for university thing. Things are involved at places. Yay ^-^\r\n\r\n##Encode##\r\n\r\nNow with the power of the GUI, encoding is a simple case of opening an image, inputting your text and clicking the encode menuitem. Bish bash bosh.\r\nOnce you open the image, because I'm too lazy to think of a smarter way, an fstream object is defined and assigned to the path of the image. Once you hit the\r\nencode menuitem, it splits the object into a header and eBuf(end buffer) accesses the text within the TextBuffer via the annoying gsteg_txt_in->get_buffer()->get_text() interface,\r\nyes, I tried looking for something better, it doesn't exist, chucks it in after the header inbetween bytes 3&7, chosen for two reasons; because they lie in the range of characters\r\nthat you can't input via traditional means, meaning it can take any characters you want, and because I'm a big QOTSA fan. There's also some minor memory cleanup which I will improve\r\nwhen I get time.\r\n\r\n##Decode##\r\n\r\nAlso the same, except in reverse. Open your image and hit the deode menuitem. I may make it more user-friendly soon.\r\nDecoding is much more simple; access the fstream object, find the \"3\" byte, located at 0x36 in MOST BMP files, the actual location of the header is defined in the header itself, I\r\nmight implement this later, doubtful as 99.9% are at 0x36, and add every byte until \"7\" to the otBuf(output text buffer), which is typecasted to a ustring so that the TextBuffer can use it.\r\nMemory cleanup happens, which also sucks. I'll sort if I get time.\r\n\r\n#Gtkmm Interface#\r\n\r\nWorks fine, does the job. May add something more user-friendly for decoding, but we will see.\r\n\r\n#Contributions#\r\n\r\nDon't. This is a university project, don't help me.\r\n\r\n#License#\r\n\r\nBSD, included.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}